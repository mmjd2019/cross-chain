# 跨链转账流程图

## 完整跨链转账流程

```mermaid
flowchart TD
    Start([用户发起跨链转账]) --> Check1{检查跨链功能是否启用}
    Check1 -->|否| Error1[返回错误: 跨链功能已禁用]
    Check1 -->|是| Check2{检查用户余额是否充足}
    
    Check2 -->|否| Error2[返回错误: 余额不足]
    Check2 -->|是| Lock[调用 crossChainLock 锁定代币]
    
    Lock --> Update1[更新用户余额: balances -= amount]
    Update1 --> Update2[更新锁定余额: lockedBalances += amount]
    Update2 --> Generate[生成锁定ID: keccak256(user, amount, targetChain, timestamp, blockNumber)]
    Generate --> Record[记录锁定信息到 crossChainLocks]
    Record --> Emit1[发出 CrossChainLocked 事件]
    
    Emit1 --> Oracle[Oracle服务监听事件]
    Oracle --> Verify1[验证锁定信息]
    Verify1 --> Notify[通知目标链桥接合约]
    
    Notify --> Bridge[目标链桥接合约接收通知]
    Bridge --> Verify2[验证解锁条件]
    Verify2 --> Unlock[调用 crossChainUnlock 解锁代币]
    
    Unlock --> Check3{检查锁定记录是否存在且未解锁}
    Check3 -->|否| Error3[返回错误: 锁定记录无效]
    Check3 -->|是| Update3[更新用户余额: balances += amount]
    Update3 --> Update4[更新锁定记录: isUnlocked = true]
    Update4 --> Emit2[发出 CrossChainUnlocked 事件]
    
    Emit2 --> Success[跨链转账成功]
    Success --> End([转账完成])
    
    Error1 --> End
    Error2 --> End
    Error3 --> End
```

## 详细步骤说明

### 阶段1: 源链锁定

```mermaid
sequenceDiagram
    participant User as 用户
    participant Token as Token合约
    participant Event as 事件系统
    participant Oracle as Oracle服务
    
    User->>Token: crossChainLock(amount, "ChainB")
    
    Note over Token: 1. 验证输入参数
    Token->>Token: require(crossChainEnabled == true)
    Token->>Token: require(amount > 0)
    Token->>Token: require(balances[user] >= amount)
    
    Note over Token: 2. 更新余额状态
    Token->>Token: balances[user] -= amount
    Token->>Token: lockedBalances[user] += amount
    
    Note over Token: 3. 生成锁定ID
    Token->>Token: lockId = keccak256(user, amount, targetChain, timestamp, blockNumber)
    
    Note over Token: 4. 记录锁定信息
    Token->>Token: crossChainLocks[lockId] = CrossChainLock{...}
    
    Note over Token: 5. 发出事件
    Token->>Event: emit CrossChainLocked(user, amount, targetChain, lockId)
    
    Token-->>User: 返回 lockId
    
    Event->>Oracle: 事件被Oracle监听
    Oracle->>Oracle: 解析事件数据
    Oracle->>Oracle: 验证锁定信息
```

### 阶段2: Oracle验证与通知

```mermaid
sequenceDiagram
    participant Oracle as Oracle服务
    participant BridgeA as 源链桥接合约
    participant BridgeB as 目标链桥接合约
    participant Monitor as 监控系统
    
    Oracle->>Oracle: 监听CrossChainLocked事件
    Oracle->>Oracle: 解析事件参数
    Oracle->>Oracle: 验证用户地址和金额
    
    Note over Oracle: 验证锁定信息
    Oracle->>BridgeA: 查询锁定详情
    BridgeA-->>Oracle: 返回锁定状态
    
    Note over Oracle: 检查目标链状态
    Oracle->>BridgeB: 检查目标链连接状态
    BridgeB-->>Oracle: 返回连接状态
    
    Note over Oracle: 准备解锁请求
    Oracle->>Oracle: 构建解锁参数
    Oracle->>Oracle: 生成解锁证明
    
    Note over Oracle: 通知目标链
    Oracle->>BridgeB: 发送解锁通知
    BridgeB->>BridgeB: 验证解锁请求
    BridgeB->>BridgeB: 调用crossChainUnlock
```

### 阶段3: 目标链解锁

```mermaid
sequenceDiagram
    participant Bridge as 桥接合约
    participant Token as Token合约
    participant User as 用户
    participant Event as 事件系统
    
    Bridge->>Token: crossChainUnlock(user, amount, "ChainA", lockId)
    
    Note over Token: 1. 验证权限
    Token->>Token: require(msg.sender == bridgeContract)
    
    Note over Token: 2. 验证输入参数
    Token->>Token: require(crossChainEnabled == true)
    Token->>Token: require(user != address(0))
    Token->>Token: require(amount > 0)
    Token->>Token: require(lockId != bytes32(0))
    
    Note over Token: 3. 检查锁定记录
    Token->>Token: require(crossChainLocks[lockId].user == address(0) || !crossChainLocks[lockId].isUnlocked)
    
    Note over Token: 4. 解锁代币
    Token->>Token: balances[user] += amount
    
    Note over Token: 5. 更新锁定记录
    Token->>Token: crossChainLocks[lockId] = CrossChainLock{user, amount, sourceChain, timestamp, true}
    
    Note over Token: 6. 发出事件
    Token->>Event: emit CrossChainUnlocked(user, amount, sourceChain, lockId)
    
    Token-->>Bridge: 返回 true
    Bridge-->>User: 解锁成功通知
```

## 错误处理流程

```mermaid
flowchart TD
    Error([发生错误]) --> Type{错误类型}
    
    Type -->|余额不足| E1[返回: Insufficient balance]
    Type -->|跨链禁用| E2[返回: Cross-chain is disabled]
    Type -->|无效地址| E3[返回: Invalid address]
    Type -->|无效金额| E4[返回: Invalid amount]
    Type -->|权限不足| E5[返回: Access denied]
    Type -->|锁定记录无效| E6[返回: Invalid lock record]
    Type -->|网络错误| E7[返回: Network error]
    
    E1 --> Rollback1[回滚余额变更]
    E2 --> Log1[记录错误日志]
    E3 --> Log2[记录错误日志]
    E4 --> Log3[记录错误日志]
    E5 --> Log4[记录错误日志]
    E6 --> Rollback2[回滚锁定记录]
    E7 --> Retry[重试机制]
    
    Rollback1 --> Notify1[通知用户]
    Rollback2 --> Notify2[通知用户]
    Log1 --> Notify3[通知用户]
    Log2 --> Notify3
    Log3 --> Notify3
    Log4 --> Notify3
    Retry --> Success{重试成功?}
    
    Success -->|是| Continue[继续流程]
    Success -->|否| Fail[标记失败]
    
    Notify1 --> End([流程结束])
    Notify2 --> End
    Notify3 --> End
    Continue --> End
    Fail --> End
```

## 状态监控流程

```mermaid
flowchart TD
    Monitor([监控系统启动]) --> Listen[监听区块链事件]
    
    Listen --> Event1{检测到CrossChainLocked事件}
    Listen --> Event2{检测到CrossChainUnlocked事件}
    Listen --> Event3{检测到Transfer事件}
    
    Event1 -->|是| Process1[处理锁定事件]
    Event2 -->|是| Process2[处理解锁事件]
    Event3 -->|是| Process3[处理转账事件]
    
    Process1 --> Update1[更新锁定状态]
    Process2 --> Update2[更新解锁状态]
    Process3 --> Update3[更新余额状态]
    
    Update1 --> Notify1[通知相关服务]
    Update2 --> Notify2[通知相关服务]
    Update3 --> Notify3[通知相关服务]
    
    Notify1 --> Log1[记录状态变更]
    Notify2 --> Log2[记录状态变更]
    Notify3 --> Log3[记录状态变更]
    
    Log1 --> Listen
    Log2 --> Listen
    Log3 --> Listen
    
    Event1 -->|否| Listen
    Event2 -->|否| Listen
    Event3 -->|否| Listen
```

## 性能优化策略

### 1. 批量处理
- 批量处理多个锁定请求
- 批量验证解锁条件
- 批量更新状态

### 2. 缓存机制
- 缓存锁定记录
- 缓存余额状态
- 缓存合约状态

### 3. 异步处理
- 异步事件处理
- 异步状态更新
- 异步通知发送

### 4. 监控告警
- 实时状态监控
- 异常情况告警
- 性能指标统计
